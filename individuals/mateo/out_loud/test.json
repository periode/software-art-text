{"questions": [["have the following javascript code", "the problem is that i in the second for loop is the same i as declared in the first for loop.", "thought that the var construct allowed multiple variables to be declared separated by commas.", "when changed i to classCt in second loop, the code worked as expected"], ["I would like to set the drawable source of my ImageView with the picture taken by the user but it's not working.", "This is my onActivityResult when the user take a picture :", "And this is the part of the Activity where I want to set the resource of my ImageView :", "When I try this, I have a path like this : \"file///storage/emulated/O/fname_xxxx.jpg\" but it's not working.", "I try with a picture picker and it work (with a path like \"/storage/emulated/...\")! I really don't know why..."], ["I have this sort of setup where I'm testing a class which is using another class, and I want to mock the latter so I'm only testing the class itself.", "nuclear_reactor.py:", "nuclear_manager.py", "test_nuclear_manager.py:", "What I'd like to test, is that the NuclearReactor.start is called once,\nbut when I run this I get:", "Which I totally understand since start is an attribute of the instance and not of the class, and I could parse the mock_calls, but isn't there a better way to check that the call of an instantiated mocked class is made?", "I could use dependency injection in NuclearManager to pass a mock NuclearReactor, but I'm thinking there would be an alternative way using just mock."]], "answers": ["\nYou only have one scope there, so there can only be one variable with the same name. You're correct that var allows multiple variables to be declared separated by commas, but you can't declare two different variables with the same name in the same scope. You're just redeclaring a variable that already exists.\nEither change it to classCt, or do what I do and use the variable j (and so on) for nested loop iterators:\nvar i, j, k, l;\nfor(i = 0; i < 10; i++){\n    for(j = 0; j < 10; j++){\n        for(k = 0; k < 10; k++){\n            for(l = 0; l < 10; l++){\n            }\n        }\n    }\n}\n\n", "\nYou are only working within one scope, the loop does not create it's own even if you use the var keyword. You are just overwriting your i variable within your current functional scope, so for example this:\nfor (var i = 0; i < 10; i++) {\n        for (var i = 5; i < 10; i++) {\n            console.log(i);\n        }\n}\n\nWill just print 5,6,7,8,9.\nIf you want to create a new scope you would have to do it using functions as is typically done in javascript:\nfor (var i = 0; i < 10; i++) {\n    (function(i) {\n        for (var i = 5; i < 10; i++) {\n            console.log(i);\n        }\n    })(i)\n}\n\nThis will print 5,6,7,8,9 on their own lines 10 times.\n", "\nWould it be possible to declare multiple variables within the same for() argument?\nSomething such as what follows:\n    for(var i = 0, l = 10; i < 10, l > 10; i += 1, l += 10){\n        console.log(i, l);\n    }\n\nIf it is, is it possible to use logical operators within the condition part of the argument?\nSomething such as what follows, based on the same example:\n    for(var i = 0, l = 10; i < 10 && l > 10; i += 1, l += 10){\n        console.log(i, l);\n    }\n\nThank you in advance.\n", "\n File imgFile = new File(getIntent().getStringExtra(\"URI\"));\n\nTranslates to\n File imgFile = new File(\"file:///storage/emulated/O/fname_xxxx.jpg\");\n\nBut it should translate to\n File imgFile = new File(\"/storage/emulated/O/fname_xxxx.jpg\");\n\nSo remove \"file://\" before use.\n", "\nHere you have to use like this\nif (getIntent().getStringExtra(\"URI\") != null) {\n    File imgFile = new File(getIntent().getStringExtra(\"URI\"));\n\n    if(imgFile.exists()){\n         Picasso.with(mContext).load(imgFile)\n                            .into(contactImage);\n    }\n}\n\nAnd you have to put this line in your gradle file\ncompile 'com.squareup.picasso:picasso:2.5.2'\n\n", "\nTo click Image \nIntent cameraIntent = new Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);\ncameraIntent.putExtra(\"URI\",Intent.URI_INTENT_SCHEME);\nstartActivityForResult(cameraIntent, CAMERA_REQUEST);\n\nReplace onActivityResult() method with below code\n@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == CAMERA_REQUEST && resultCode == Activity.RESULT_OK) {\n        Bitmap photo = (Bitmap) data.getExtras().get(\"URI\");\n        imageView.setImageBitmap(photo);\n    }\n}\n\n", "\nI think you are parcel wrong URI data in intent Bundle try below code\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\nif (resultCode == RESULT_OK) {\n    if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) {\n          Intent intent = new Intent(this, MyNewActivity.class);\n          intent.putExtra(\"URI\", data.getData().toString());\n          startActivity(intent);\n    }\n}\n\nthis may help\n", "\nI found the solution replacing the \"file://\" by \"\" :\nFile imgFile = new File(getIntent().getStringExtra(\"URI\").replace(\"file://\", \"\"));\n\nSo I get :\nif (getIntent().getStringExtra(\"URI\") != null) {\n            File imgFile = new File(getIntent().getStringExtra(\"URI\").replace(\"file://\", \"\"));\n            if(imgFile.exists()){\n                Picasso.with(this).load(imgFile).into(myImageView);\n            }\n        }\n\n", "\nThis worked for me\n    if (getIntent().getStringExtra(\"URI\") != null) {\n        Uri myUri = Uri.parse(extras.getString(\"URI\"));\n        Picasso.with(RegisterActivity.this)\n               .load(selectedImage)\n               .into(contactImage);\n    }\n\n", "\nTry Below Code for both Pic taken by Camera & also pick by gallery \n@Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        if (resultCode == this.RESULT_OK) {\n            if (requestCode == SELECT_FILE)\n                onSelectFromGalleryResult(data);\n            else if (requestCode == REQUEST_CAMERA)\n                onCaptureImageResult(data);\n        }\n    }\n\n    private void onCaptureImageResult(Intent data) {\n        Bitmap thumbnail = (Bitmap) data.getExtras().get(\"data\");\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        thumbnail.compress(Bitmap.CompressFormat.JPEG, 90, bytes);\n\n        File destination = new File(Environment.getExternalStorageDirectory(),\n                System.currentTimeMillis() + \".jpg\");\n        FileOutputStream fo;\n        try {\n            destination.createNewFile();\n            fo = new FileOutputStream(destination);\n            fo.write(bytes.toByteArray());\n            fo.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        profileIV.setImageBitmap(thumbnail);\n\n        // CALL THIS METHOD TO GET THE URI FROM THE BITMAP\n        Uri tempUri = getImageUri(getApplicationContext(), thumbnail);\n\n        // CALL THIS METHOD TO GET THE ACTUAL PATH\n         file = new File(getRealPathFromURI(tempUri));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private void onSelectFromGalleryResult(Intent data) {\n\n        Bitmap bm=null;\n        if (data != null) {\n            try {\n                bm = MediaStore.Images.Media.getBitmap(getApplicationContext().getContentResolver(), data.getData());\n\n                // CALL THIS METHOD TO GET THE URI FROM THE BITMAP\n                Uri tempUri = getImageUri(getApplicationContext(), bm);\n\n                // CALL THIS METHOD TO GET THE ACTUAL PATH\n                 file = new File(getRealPathFromURI(tempUri));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        profileIV.setImageBitmap(bm);\n    }\n\n\n\n    public String getRealPathFromURI(Uri uri) {\n        Cursor cursor = getContentResolver().query(uri, null, null, null, null);\n        cursor.moveToFirst();\n        int idx = cursor.getColumnIndex(MediaStore.Images.ImageColumns.DATA);\n        return cursor.getString(idx);\n    }\n\n", "\nThe way I use mocks is like this: (Code is Python 3)\nfrom unittest.mock import MagicMock\n\nclass NuclearManager():\n    def __init__(self, reactor):\n        print(\"manager creating the nuclear reactor\")\n        self.reactor = reactor\n\n    def start(self):\n        print(\"manager starting the nuclear reactor\")\n        self.reactor.start()\n\n\ndef test():\n    mock_reactor = MagicMock()\n    nuke = NuclearManager(mock_reactor)\n    nuke.start()\n    nuke.start()\n\n    # These two prints would actually be asserts of some sort\n    print(mock_reactor.mock_calls)\n    print(mock_reactor.start.call_count)\n\ntest()\n\nOutput:\nmanager creating the nuclear reactor\nmanager starting the nuclear reactor\nmanager starting the nuclear reactor\n[call.start(), call.start()]\n2\n\n", "\nYou are indeed testing if start has been called directly on the class, which your code does not. You can test the method on the instance directly; remember that an instance is produced by calling the class:\nprint mock_reactor.return_value.calls\nprint mock_reactor.return_value.start.call_count\n\nThe Mock.return_value attribute is the result of the call to the mocked class, so the instance.\nYou can also just call the mock. Mocks by default always return the exact same object when called, a new mock representing that return value:\nprint mock_reactor().calls\nprint mock_reactor().start.call_count\n\nThe result of calling a mock instance, and the mock instance return_value attribute, are one and the same.\nYou may want to use mock.patch() to handle the patching, rather than by direct assignment; this makes sure that the patch is removed again so that other tests can make their own decisions on what is mocked:\nimport mock\nfrom nuclear_manager import NuclearManager\n\n@mock.patch('nuclear_manager.NuclearReactor')\ndef test(mock_reactor):\n    nuke = NuclearManager()\n    nuke.start()\n    nuke.start()\n\n    instance = mock_reactor.return_value\n    assert instance.start.call_count == 2\n    instance.assert_called()\n\n"]}